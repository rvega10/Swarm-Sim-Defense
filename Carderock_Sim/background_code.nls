extensions [palette
            profiler]
;
; Variable
;
breed [ traps trap]
breed [ stags stag]
breed [centroids centroid]
breed [ dogs dog]
breed [cues cue]
breed [tails tail]
breed [discs disc]
breed[ place-holders place-holder]

globals [ tick-delta
          n
          i
          time-to-first-arrival
          time-to-first-see-list
          time-of-first-stag-detected
          time-of-stuck-stag
          rand-xcor
          rand-ycor
          rand-xcor2
          rand-ycor2
          sr_patches
          end_flag
          stuck_flag
          total_velocity_squared
          total_distance_traveled
          number-of-second-traps
          sim_ran_count
          score_list
          score
          clear_path_occurance
          number-of-robots
          cue-x-out
          cue-y-out
          win-loss-list
          win-loss-ratio
         ]


traps-own [
          velocity
           angular-velocity   ;; angular velocity of heading/yaw
           true_velocity
           V
           inputs             ;; input forces
           closest-turtle     ;; closest target
           impact-x
           impact-y
           impact-angle
           rand-x
           rand-y
           speed-w-noise
           turning-w-noise
           levy_time
           mass
           wait_ticks
           rand_turn
           step_count
           flight_count
           pre_flight_count
           step_time
           flight_time
           pre_flight_time
           closest-turtles
           closest-turtle2
           body_direct
           body_direct2
           coll_angle2
           detection_response_type
           fov-list-traps
           fov-list-green-traps
           detect_traps?
           detect_stags?
           detect_dogs?
           fov-list-stags
           stuck_count
           idiosyncratic_val
           detect_step_count
           sleep_timer
           rand-head-distrbuance
           distance_traveled
           energy
           ricky_energy
           fov-list-patches
           stag_caught_flag
;           body_v_x
;           body_v_y
           temp-turning-val
           random_switch-timer
           alternating_procedure_val
           fov-list-traps-same1
           fov-list-traps-same2
           fov-list-traps-other1
           fov-list-traps-other2
           fov-list-dogs
          ]
dogs-own [
          velocity
           angular-velocity   ;; angular velocity of heading/yaw
           true_velocity
           V
           inputs             ;; input forces
           closest-turtle     ;; closest target
           impact-x
           impact-y
           impact-angle
           rand-x
           rand-y
           speed-w-noise
           turning-w-noise
           levy_time
           mass
           wait_ticks
           rand_turn
           step_count
           flight_count
           pre_flight_count
           step_time
           flight_time
           pre_flight_time
           closest-turtles
           closest-turtle2
           body_direct
           body_direct2
           coll_angle2
           detection_response_type
           fov-list-traps
           fov-list-green-traps
           detect_traps?
           detect_stags?
           detect_dogs?
           fov-list-stags
           stuck_count
           idiosyncratic_val
           detect_step_count
           sleep_timer
           rand-head-distrbuance
           distance_traveled
           energy
           ricky_energy
           fov-list-patches
           stag_caught_flag
;           body_v_x
;           body_v_y
           temp-turning-val
           random_switch-timer
           alternating_procedure_val
           fov-list-traps-same1
           fov-list-traps-same2
           fov-list-traps-other1
           fov-list-traps-other2
           fov-list-dogs
           measured_stag_x-position_list
           measured_stag_y-position_list
           measured_stag_time_list
           predicted_stag_heading
           predicted_stag_speed
           predicted_stag_ang-velocity
           old_predicted_stag_heading
           predicted_stag_speed_list
           predicted_stag_ang-velocity_list
          ]


stags-own [
           velocity
           angular-velocity   ;; angular velocity of heading/yaw
           true_velocity
           V
           inputs             ;; input forces
           closest-turtle     ;; closest target
           impact-x
           impact-y
           impact-angle
           rand-x
           rand-y
           rand-head-distrbuance
           speed-w-noise
           turning-w-noise
           levy_time
           mass
           wait_ticks
           rand_turn
           step_count
           flight_count
           pre_flight_count
           step_time
           flight_time
           pre_flight_time
           closest-turtles
           closest-turtle2
           body_direct
           body_direct2
           coll_angle2
           detection_response_type
           stag_caught_flag
           fov-list-stags
           fov-list-traps
           detect_stags?
           detect_dogs?
           detect_traps?
           stuck_count
           idiosyncratic_val
           furthest_ycor
           trapped_count
           detect_step_count
           fov-list-patches
           direction_angle
           Im-detected-flag
           fov-list-dogs
          ]

patches-own [
            real-bearing-patch
            closest-trap-dist
          ]

discs-own [
            age
          ]

cues-own [
            age
          ]



;;
;; Setup Procedures
;;
to setup
  clear-all
  random-seed seed-no

  set tick-delta 0.1 ; 10 ticks in one second
  
  
  set cue-x-out "N/A"
  set cue-y-out "N/A"

  let gr (range  min-pycor max-pycor 1)
  set rand-xcor one-of gr
  set rand-ycor one-of gr


  set time-to-first-see-list (list )
  set score_list (list )
  set win-loss-list (list )

  ask patches
    [
        set pcolor white

    ]


  ;creates robots
  set number-of-robots (number-of-stags + number-of-traps + number-of-dogs)

  set n number-of-robots
  
  while [n > (number-of-traps + number-of-dogs)]
  [
   make_stag
   set n (n - 1)
  ]

  while [n > number-of-dogs]
  [
   make_trap
   set n (n - 1)
  ]
  
  while [n > 0]
  [
   make_dog
   set n (n - 1)
  ]

   trap_setup_strict
   dog_setup_strict
  
  
  
  
  
  
  
  ; adds extra turtles to show predicted path of stag
  create-cues (20 * number-of-stags)
  [
    setxy max-pxcor max-pycor
    set shape "boat"
    set size 90 / meters-per-patch ; 90 meter length
    set color yellow

    ht
  ]
  
  create-centroids 1
  [
    setxy max-pxcor max-pycor
    set shape "circle"
    set size 50 / meters-per-patch
    ht
  ]

  ; adds extra "ghost" turtles that make adding and removing agents during simulation a bit easier
  create-place-holders 20
  [
    setxy max-pxcor max-pycor
    ht
  ]

  set-default-shape discs "ring"

  reset-ticks
end





to stag_procedure
  set_actuating_and_extra_variables ;does the procedure to set the speed and turning rate etc.
  do_sensing ; does the sensing to detect whatever the stag is set to detect

  ifelse detect_step_count > 0 ; if value is positive, it performs whatever the detection response is (i.e. if set to 'turn-away-in-place" it will make sure it turns in place for a full second even if it detects something else
    [
      detection_response_procedure ; if agent is detected, it stops everything and executes the desired algorithm for one second

      set detect_step_count (detect_step_count - 1) ;counts down
      set color red
    ]
    [
     ifelse length fov-list-traps > 0  or length fov-list-dogs > 0; if one or more traps are detected, it reacts according to whatever the selected algorithm is (default is turn away in place
       [  
         set detection_response_type "turn-away-in-place"        
         set detect_step_count 1;
       ]
       [
         ifelse stuck_count > 100
           [
            set detection_response_type "90-in-place"
            choose_rand_turn
            set detect_step_count (1 / tick-delta)
            set stuck_count 0
           ]
           [
              go_to_goal
              set color orange

           ]
       ]
   ]
    


    ifelse ycor > furthest_ycor
    [
      set furthest_ycor ycor
      set trapped_count 0
    ]
    [
      set trapped_count trapped_count + 1
    ]

    if ycor > 35
    [
      set trapped_count 0
    ]


 update_agent_state; updates states of agents (i.e. position and heading)





end

to stag_procedure_manual ; buttons control what the inputs of the stag is, this is here to make the stag actually use those inputs to move
  set_actuating_and_extra_variables
  do_sensing

    ifelse ycor > furthest_ycor
    [
      set furthest_ycor ycor
      set trapped_count 0
    ]
    [
      set trapped_count trapped_count + 1
    ]

    if ycor > 35
    [
      set trapped_count 0
    ]

 update_agent_state; updates states of agents (i.e. position and heading)



end


to trap_procedure
  set_actuating_and_extra_variables ;does the procedure to set the speed and turning rate etc.
  do_sensing ; does the sensing to detect whatever the trap is set to detect





;  ifelse length fov-list-stags > 0 ; if one or more stags are detected, it does what is in the first set of brackets (forward towards closest stag)
;    [
;      set detection_response_type "forward"
;      detection_response_procedure
;      set color green
;    ]
;    [
;      ifelse detect_step_count > 0
;        [
;          detection_response_procedure ; if agent is detected, it stops everything and executes the desired algorithm for one second
;
;          set detect_step_count (detect_step_count - 1) ;counts down
;          set color blue
;        ]
;        [
;          
;          ifelse length fov-list-traps > 0 and sleep_timer < 0 ; if one or more traps are detected, it reacts according to whatever the selected algorithm is (default is turn away in place. (sleep timer is added so it doesnt get stuck in infite loop of turning when face to face
;            [
;              ifelse selected_algorithm_traps = "Milling"
;                [
;                  set detection_response_type "mill-response"
;                  set detect_step_count (0.25 / tick-delta)
;                ]
;                [
;                  ifelse selected_algorithm_traps = "Diffusing"
;                  [
;                    set detection_response_type "diffuse-response"
;                    set detect_step_count (0.25 / tick-delta)
;                  ]
;                  [
;                    ifelse selected_algorithm_traps = "Diffusing2"
;                  [
;                    set detection_response_type "diffuse-response2"
;                    set detect_step_count (0.25 / tick-delta)
;                  ]
;                  [
;                    set detection_response_type "180-in-place"
;                    choose_rand_turn
;                    set sleep_timer 20
;                    set detect_step_count (1 / tick-delta)
;
;                  ]
;                  ]
;                ]
;            ]
;            [
;                ifelse stuck_count > 20
;                [
;                 set detection_response_type "180-in-place"
;                 choose_rand_turn
;                 set detect_step_count (1 / tick-delta)
;                 set stuck_count 0
;                ]
;                [
;                  select_alg_procedure1
;                  set color violet
;                ]
;
;                set sleep_timer (sleep_timer - 1)
;            ]
;            
;       ]
;    ]
;  
  ifelse stuck_count > 20
                [
                 set detection_response_type "180-in-place"
                 choose_rand_turn
                 set detect_step_count (1 / tick-delta)
                 set stuck_count 0
                ]
                [
                  select_alg_procedure1
                  set color violet
                ]


 update_agent_state; updates states of agents (i.e. position and heading)

 if count stags > 0 and (count stags in-cone (vision-distance-traps / meters-per-patch) vision-cone-traps) > 0
  [
    ask stags in-cone (vision-distance-traps / meters-per-patch) vision-cone-traps
    [
     set Im-detected-flag 1
    ]
  ]

  check_if_touching_stag

end

to dog_procedure
  set_actuating_and_extra_variables ;does the procedure to set the speed and turning rate etc.
  do_sensing ; does the sensing to detect whatever the trap is set to detect
  
  intercept

  
  


 update_agent_state; updates states of agents (i.e. position and heading)

 if count stags > 0 and (count stags in-cone (vision-distance-traps / meters-per-patch) vision-cone-traps) > 0
  [
    ask stags in-cone (vision-distance-traps / meters-per-patch) vision-cone-traps
    [
     set Im-detected-flag 1
    ]
  ]

  check_if_touching_stag

end

to check_if_touching_stag
  let bearing_to_stag 0
  
;  ifelse count stags > 0 and distance min-one-of stags [distance myself] < (size + mean [size] of stags) / 2
;  [ set stag_caught_flag 1]
;  [ set stag_caught_flag 0]
;  
  
  let my_x xcor
  let my_y ycor
  let my_size size
  
  let stag_x [xcor] of stag 0
  let stag_y [ycor] of stag 0
  let stag_heading [heading] of stag 0 ; 0 deg is pointing North
  set stag_heading (90 - stag_heading) ; updates heading to be in traditional cartestion coordiantes (0 deg is pointing East)
  let stag_major_axis_length [size] of stag 0  ; major axis is the length of stag which is 90m
  let stag_minor_axis_length ([size] of stag 0) / 6 ; minor axis is width of stag which is 15m or 16.6% if length
  
  
  
  let x_diff (my_x - stag_x)
  let y_diff (my_y - stag_y)
  
  if  not (x_diff = 0 and y_diff = 0)
  [set bearing_to_stag atan y_diff x_diff]
  
  let my_x_to_stag_frame ((x_diff * cos(stag_heading)) + (y_diff * sin (stag_heading)))
  let my_y_to_stag_frame ((-1 * x_diff * sin(stag_heading)) + (y_diff * cos (stag_heading)))
  
  let ellipse_eq ((my_x_to_stag_frame ^ 2) / (((stag_major_axis_length + my_size)/ 2)^ 2)) + ((my_y_to_stag_frame ^ 2) / (((stag_minor_axis_length + my_size)/ 2)^ 2))
  
  ifelse ellipse_eq <= 1
  [ set stag_caught_flag 1]
  [ set stag_caught_flag 0]
  
  
  
end



to intercept
  

  if length fov-list-stags > 0
  [
    ifelse length measured_stag_x-position_list > 100
      [
       set measured_stag_x-position_list remove-item 0 measured_stag_x-position_list
        set measured_stag_x-position_list lput ([xcor] of stag 0) measured_stag_x-position_list
       ]
      [
        set measured_stag_x-position_list lput ([xcor] of stag 0) measured_stag_x-position_list
      ]
    
    ifelse length measured_stag_y-position_list > 100
      [
       set measured_stag_y-position_list remove-item 0 measured_stag_y-position_list
        set measured_stag_y-position_list lput ([ycor] of stag 0) measured_stag_y-position_list
       ]
      [
        set measured_stag_y-position_list lput ([ycor] of stag 0) measured_stag_y-position_list
      ]
    
    ifelse length measured_stag_time_list > 100
      [
       set measured_stag_time_list remove-item 0 measured_stag_time_list
        set measured_stag_time_list lput (ticks) measured_stag_time_list
       ]
      [
        set measured_stag_time_list lput (ticks) measured_stag_time_list
      ]
  ]
  
  ifelse length measured_stag_x-position_list > 3
  [
    let delta-x (last measured_stag_x-position_list - item (length measured_stag_x-position_list - 2) measured_stag_x-position_list) / (last measured_stag_time_list - item (length measured_stag_time_list - 2) measured_stag_time_list)
    let delta-y (last measured_stag_y-position_list - item (length measured_stag_y-position_list - 2) measured_stag_y-position_list) / (last measured_stag_time_list - item (length measured_stag_time_list - 2) measured_stag_time_list)
  
    
    set predicted_stag_speed sqrt (delta-x ^ 2 + delta-y ^ 2)
    if not (delta-x = 0 and delta-y = 0)
      [set predicted_stag_heading atan delta-x delta-y]
    
    set predicted_stag_ang-velocity ((predicted_stag_heading - old_predicted_stag_heading) / (last measured_stag_time_list - item (length measured_stag_time_list - 2) measured_stag_time_list))
    
    set old_predicted_stag_heading predicted_stag_heading
    
    
  ]
  [
    set predicted_stag_speed 0
    set predicted_stag_heading 0
  ]
  
  ifelse length predicted_stag_speed_list > 100
    [
     set predicted_stag_speed_list remove-item 0 predicted_stag_speed_list
      set predicted_stag_speed_list lput predicted_stag_speed predicted_stag_speed_list
     ]
    [
      set predicted_stag_speed_list lput predicted_stag_speed predicted_stag_speed_list
    ]
  
  ifelse length predicted_stag_ang-velocity_list > 100
    [
     set predicted_stag_ang-velocity_list remove-item 0 predicted_stag_ang-velocity_list
      set predicted_stag_ang-velocity_list lput predicted_stag_ang-velocity predicted_stag_ang-velocity_list
     ]
    [
      set predicted_stag_ang-velocity_list lput predicted_stag_ang-velocity predicted_stag_ang-velocity_list
    ]
  
  
  if length measured_stag_x-position_list > 3
  [place-cues]
  
  let target_bearing (0) - heading
  
  
  
  ifelse lead_stag?
  [
;    let target-cue (max-one-of (cues with [[ycor] of self < [ycor] of stag 0]) [distance stag 0] )
    let target-cue min-one-of cues [abs(distance stag 0 - distance myself)]
    ask target-cue
    [set color blue]
    ifelse distance min-one-of cues [distance myself] < (predicted_stag_speed * meters-per-patch) 
    [
      set target_bearing (towards min-one-of stags [distance myself]) - heading
    ]
    [
      ifelse length measured_stag_x-position_list <= 3
      [
        set target_bearing (0) - heading
      ]
      [
        set target_bearing (towards target-cue ) - heading
        
      ]
    ]
  ]
  [
    set target_bearing (towards min-one-of stags [distance myself]) - heading
  ]
  
  ifelse length measured_stag_x-position_list > 3
      [
        ifelse target_bearing < -180
          [
            set target_bearing target_bearing + 360
           ]
          [
            ifelse target_bearing > 180
            [set target_bearing target_bearing - 360]
            [set target_bearing target_bearing]
          ]
       
        (ifelse ((target_bearing) > -1 and target_bearing < 1)
          [set inputs (list (speed-w-noise) 90 0)]
          (target_bearing) > 1
          [set inputs (list (speed-w-noise) 90 turning-w-noise)]
          (target_bearing) < -1
          [set inputs (list (speed-w-noise) 90 (- turning-w-noise))])
      ]
      [
        set inputs (list (0) 90 (0))
      ]
  
  
  
  
end


to place-cues
  
  set i (count stags + count traps + count dogs)
  
  let current-x last measured_stag_x-position_list
  let current-y last measured_stag_y-position_list
  let current-heading predicted_stag_heading
  
  let predicted_speed mean predicted_stag_speed_list
  let predicted_ang-velocity mean predicted_stag_ang-velocity_list
  
  while [i < (count stags + count traps + count dogs + count cues)]
    [
      ask cue i 
      [
        set color yellow
        st
        let cue-x 0
        let cue-y 0
        let cue-heading 0
        
        ifelse abs predicted_ang-velocity < 0.0001
        [
         set cue-heading current-heading + (predicted_ang-velocity * meters-per-patch * (i - (count stags + count traps + count dogs) + 1))
         set cue-x current-x + (predicted_speed * sin(cue-heading) * meters-per-patch * (i - (count stags + count traps + count dogs) + 1)) ;; i think the error is coming from this part becuase i am already calculateing future heading but then still multipling counter?
         set cue-y current-y + (predicted_speed * cos(cue-heading)* meters-per-patch * (i - (count stags + count traps + count dogs) + 1))
        
        ]
        [
        
        let x_c current-x + (predicted_speed / (predicted_ang-velocity * pi / 180)) * cos(current-heading)
        let y_c current-y - (predicted_speed / (predicted_ang-velocity * pi / 180)) * sin(current-heading)
        
        
        set cue-heading current-heading + (predicted_ang-velocity * meters-per-patch * (i - (count stags + count traps + count dogs) + 1))
        set cue-x x_c + ((predicted_speed / (predicted_ang-velocity * pi / 180)) * sin(cue-heading - 90)) ;* 100 * (i - (count stags + count traps + count dogs) + 1)) ;; i think the error is coming from this part becuase i am already calculateing future heading but then still multipling counter?
        set cue-y y_c + ((predicted_speed / (predicted_ang-velocity * pi / 180)) * cos(cue-heading - 90) );* 100 * (i - (count stags + count traps + count dogs) + 1))
        ]
        
        
        
        if cue-x > max-pxcor
         [
           set cue-x max-pxcor  
           ifelse cue-y-out = "N/A"
            [
              set cue-y-out cue-y
              set cue-y cue-y-out
            ]
            [set cue-y cue-y-out]
            
         ]
        
        if cue-x < min-pxcor
        [
          set cue-x min-pxcor
          ifelse cue-y-out = "N/A"
            [
              set cue-y-out cue-y
              set cue-y cue-y-out
            ]
            [set cue-y cue-y-out] 
        ]
        
        if cue-y > max-pycor
         [
           set cue-y max-pycor
           ifelse cue-x-out = "N/A"
            [
              set cue-x-out cue-x
              set cue-x cue-x-out
            ]
            [set cue-x cue-x-out]
         ]
        
        if cue-y < min-pycor
        [
          set cue-y min-pycor
          ifelse cue-x-out = "N/A"
            [
              set cue-x-out cue-x
              set cue-x cue-x-out
            ]
            [set cue-x cue-x-out] 
        ]
        
        setxy cue-x cue-y
        set heading cue-heading
      ]
      set i (i + 1)
    ]
  set cue-x-out "N/A"
  set cue-y-out "N/A"
  
  
end


to background_procedures
 clear-paint

ifelse paint_fov?
  [
    ask discs
      [
         set age age + 1
         if age = 1 [ die ]
       ]

    ask traps
      [
        (ifelse vision-cone-traps = 360
          [
            hatch-discs 1
                [
                  set size 2 * (vision-distance-traps / meters-per-patch)
                  set heading ([heading] of myself)
                  palette:set-transparency 50
                ]
          ]
          vision-cone-traps = 180
          [
            hatch-discs 1
                [
                  set size 2 * (vision-distance-traps / meters-per-patch)
                  set heading ([heading] of myself)
                  set shape "180-deg-fov"
                  palette:set-transparency 50
                ]
          ]
          vision-cone-traps = 90
          [
            hatch-discs 1
                [
                  set size 2 * (vision-distance-traps / meters-per-patch)
                  set heading ([heading] of myself)
                  set shape "90-deg-fov"
                  palette:set-transparency 50
                ]
          ]
          vision-cone-traps = 45
          [
            hatch-discs 1
                [
                  set size 2 * (vision-distance-traps / meters-per-patch)
                  set heading ([heading] of myself)
                  set shape "45-deg-fov"
                  palette:set-transparency 50
                ]
          ]
          vision-cone-traps = 60
          [
            hatch-discs 1
                [
                  set size 2 * (vision-distance-traps / meters-per-patch)
                  set heading ([heading] of myself)
                  set shape "60-deg-fov"
                  palette:set-transparency 50
                ]
          ]
          vision-cone-traps = 30
          [
            hatch-discs 1
                [
                  set size 2 * (vision-distance-traps / meters-per-patch)
                  set heading ([heading] of myself)
                  set shape "30-deg-fov"
                  palette:set-transparency 50
                ]
          ]
          [
            paint-patches-in-FOV
          ]
          )

      ]

    ask stags
      [
         (ifelse vision-cone-stags = 360
          [
            hatch-discs 1
                [
                  set size 2 * (vision-distance-stags / meters-per-patch)
                  set heading ([heading] of myself)
                  palette:set-transparency 50
                ]
          ]
          vision-cone-stags = 180
          [
            hatch-discs 1
                [
                  set size 2 * (vision-distance-stags / meters-per-patch)
                  set heading ([heading] of myself)
                  set shape "180-deg-fov"
                  palette:set-transparency 50
                ]
          ]
          vision-cone-stags = 90
          [
            hatch-discs 1
                [
                  set size 2 * (vision-distance-stags / meters-per-patch)
                  set heading ([heading] of myself)
                  set shape "90-deg-fov"
                  palette:set-transparency 50
                ]
          ]
          vision-cone-stags = 45
          [
            hatch-discs 1
                [
                  set size 2 * (vision-distance-stags / meters-per-patch)
                  set heading ([heading] of myself)
                  set shape "45-deg-fov"
                  palette:set-transparency 50
                ]
          ]
          vision-cone-stags = 60
          [
            hatch-discs 1
                [
                  set size 2 * (vision-distance-stags / meters-per-patch)
                  set heading ([heading] of myself)
                  set shape "60-deg-fov"
                  palette:set-transparency 50
                ]
          ]
          vision-cone-stags = 30
          [
            hatch-discs 1
                [
                  set size 2 * (vision-distance-stags / meters-per-patch)
                  set heading ([heading] of myself)
                  set shape "30-deg-fov"
                  palette:set-transparency 50
                ]
          ]
          [
            paint-patches-in-FOV
          ]
          )
       ]
    
    ask dogs
      [
         (ifelse vision-cone-dogs = 360
          [
            hatch-discs 1
                [
                  set size 2 * (vision-distance-dogs / meters-per-patch)
                  set heading ([heading] of myself)
                  palette:set-transparency 50
                ]
          ]
          vision-cone-dogs = 180
          [
            hatch-discs 1
                [
                  set size 2 * (vision-distance-dogs / meters-per-patch)
                  set heading ([heading] of myself)
                  set shape "180-deg-fov"
                  palette:set-transparency 50
                ]
          ]
          vision-cone-dogs = 90
          [
            hatch-discs 1
                [
                  set size 2 * (vision-distance-dogs / meters-per-patch)
                  set heading ([heading] of myself)
                  set shape "90-deg-fov"
                  palette:set-transparency 50
                ]
          ]
          vision-cone-dogs = 45
          [
            hatch-discs 1
                [
                  set size 2 * (vision-distance-dogs / meters-per-patch)
                  set heading ([heading] of myself)
                  set shape "45-deg-fov"
                  palette:set-transparency 50
                ]
          ]
          vision-cone-dogs = 60
          [
            hatch-discs 1
                [
                  set size 2 * (vision-distance-dogs / meters-per-patch)
                  set heading ([heading] of myself)
                  set shape "60-deg-fov"
                  palette:set-transparency 50
                ]
          ]
          vision-cone-dogs = 30
          [
            hatch-discs 1
                [
                  set size 2 * (vision-distance-dogs / meters-per-patch)
                  set heading ([heading] of myself)
                  set shape "30-deg-fov"
                  palette:set-transparency 50
                ]
          ]
          [
            paint-patches-in-FOV
          ]
          )
       ]
  ]
  [
    ask discs [die]
  ]

  ifelse draw_path?
  [
    ask stags [pd]
    ask traps [pd]
    ask dogs [pd]
  ]
  [
    ask stags [pu]
    ask traps [pu]
    ask dogs [pu]
  ]
end

to measure_results

    if time-to-first-arrival = 0
    [
      if count stags with [pycor <= (min-pycor + size / 2)] > 0
      [set time-to-first-arrival ticks]
    ]
   
    if time-of-first-stag-detected = 0
    [
      if count traps with [stag_caught_flag = 1] > 0 or count dogs with [stag_caught_flag = 1] > 0
      [set time-of-first-stag-detected ticks]
    ]

  set total_distance_traveled sum [distance_traveled] of traps
  set total_velocity_squared sum [energy] of traps

      if (time-to-first-arrival > 0) or  (time-of-first-stag-detected > 0) or (time-of-stuck-stag  > 0)
      [set end_flag 1]
end




to select_alg_procedure1

  if selected_algorithm_traps = "Standard Random"
  [standard_random_walk]

  if selected_algorithm_traps = "Levy"
  [real_levy]

  if selected_algorithm_traps = "Lie and Wait"
  [lie-and-wait]

  if selected_algorithm_traps = "Straight"
  [straight]


end

; stag algorithm - - - - - - - - - - -
to go_to_goal ; stag attempts to drive its heading towards the south end of the environment
   let target_bearing 180 - heading

      ifelse target_bearing < -180
        [
          set target_bearing target_bearing + 360
         ]
        [
          ifelse target_bearing > 180
          [set target_bearing target_bearing - 360]
          [set target_bearing target_bearing]
        ]

      (ifelse ((target_bearing) > -1 and target_bearing < 1)
        [set inputs (list (speed-w-noise) 90 0)]
        (target_bearing) > 1
        [set inputs (list (speed-w-noise) 90 turning-w-noise)]
        (target_bearing) < -1
        [set inputs (list (speed-w-noise) 90 (- turning-w-noise))])

end


; trap algorithms --------------

to straight ; go straight forwards
  set inputs (list speed-w-noise 90 0)
end

to lie-and-wait ; stay in place
      set inputs (list 0 90 0)
end


to standard_random_walk ;

  ifelse step_count < (step_length_fixed + idiosyncratic_val) ; while step count is less than the set step_length, it should either be turning in place or going straight
  [

    ifelse step_count < (1 / tick-delta) ; for the first 10 ticks of the "step", turn in place at a rate of rand_turn
     [
       set inputs (list (0) 90 rand_turn)
     ]
     [
      set inputs (list speed-w-noise 90 0) ; if nothing is detected, goes straight forward at a speed of speed-w-noise

     ]

    set step_count step_count + 1 ;counts up
  ]
  [
     choose_rand_turn ; at the end of the step, choose random turning rate
     set step_count 0 ; reset turning rate to zero
  ]

end


to real_levy  ;; classic levy that chooses direction at beginning of step and moves straight in that line. Step lengths are chosen from levy distribution

  ifelse step_count < step_time; while step count is less than the the randomly chosen step_length, it should either be turning in place or going straight
  [

    ifelse step_count < (1 / tick-delta) ; for the first 10 ticks of the "step", turn in place at a rate of rand_turn
     [
       set color blue
        set inputs (list (0) 90 rand_turn)
     ]
     [
       set color red
       set inputs (list speed-w-noise 90 0) ; if nothing is detected, goes straight forward at a speed of speed-w-noise
     ]

    set step_count step_count + 1 ;increment step count
  ]
  [
      ; at the end of the step, choose a new step length from levy distribution and choose random turning rate
       set step_time round (100 * (1 / (random-gamma 0.5 (c / 2  ))))
       while [step_time > round (max_levy_time / tick-delta)]
         [set step_time round (100 * (1 / (random-gamma 0.5 (c / 2 ))))]

       choose_rand_turn
       set step_count 0
  ]
end



;
;
;-------------- Nested functions and Setup Procedures below--------------
;
;

to detection_response_procedure
  let target (max-one-of place-holders [distance myself]);
  let hostile (max-one-of place-holders [distance myself])


   set target one-of stags
   
  if detection_response_type = "turn-away-in-place"
    [
      if breed = stags
      [
        set hostile min-one-of dogs [distance myself] 
      ]
      let hostile_bearing towards hostile - heading

      ifelse hostile_bearing < -180
        [
          set hostile_bearing hostile_bearing + 360
         ]
        [
          ifelse hostile_bearing > 180
          [set hostile_bearing hostile_bearing - 360]
          [set hostile_bearing hostile_bearing]
        ]

      ifelse (hostile_bearing) > 0
        [set inputs (list (speed-w-noise) 90(- turning-w-noise))]
        [set inputs (list (speed-w-noise) 90( turning-w-noise))]
     ]

   

    if detection_response_type = "180-in-place"
    [
      set inputs (list (0) 90 180)
    ]

    if detection_response_type = "stop"
      [
        set inputs (list (0) 90 0)
      ]


    if detection_response_type = "forward"
    [
      let target_bearing towards target - heading

      ifelse target_bearing < -180
        [
          set target_bearing target_bearing + 360
         ]
        [
          ifelse target_bearing > 180
          [set target_bearing target_bearing - 360]
          [set target_bearing target_bearing]
        ]


      ifelse (target_bearing) > 0
        [set inputs (list (speed-w-noise) 90 turning-w-noise)]
        [set inputs (list (speed-w-noise) 90 (- turning-w-noise))]
     ]
  
end

to choose_rand_turn
  let turning-rate-val 0
  if member? self traps
    [
      set turning-rate-val turning-rate-rw
    ]

  if distribution_for_direction = "uniform"
  [set rand_turn (- turning-rate-val) + (random (2 * turning-rate-val + 1)) ]

  if distribution_for_direction = "gaussian"
  [ set rand_turn round (random-normal 0 (turning-rate-val / 3))]

  if distribution_for_direction = "triangle"
  [set rand_turn (random turning-rate-val) - (random turning-rate-val) ]
end


to set_actuating_and_extra_variables
  if ticks mod 1 = 0
  [
    set rand-x random-normal 0 state-disturbance_xy
    set rand-y random-normal 0 state-disturbance_xy
    set rand-head-distrbuance random-normal 0 state-disturbance_head
  ]

  (ifelse member? self traps
  [
     set turning-w-noise random-normal (turning-rate-traps) noise-actuating-turning
     set speed-w-noise random-normal (speed-traps / meters-per-patch) (noise-actuating-speed)
      
  ]
  member? self stags
  [
      
    set speed-w-noise random-normal (speed-stags / meters-per-patch) (noise-actuating-speed)
    set turning-w-noise random-normal (turning-rate-stags) noise-actuating-turning
      
  ]
  member? self dogs
  [
      
    set speed-w-noise random-normal (speed-dogs / meters-per-patch) (noise-actuating-speed)
    set turning-w-noise random-normal (turning-rate-dogs) noise-actuating-turning
      
  ]
  )
end

to do_sensing

  ifelse detect_stags?
    [find-stags-in-FOV]
    [set fov-list-stags (list)]

  ifelse detect_traps?
    [find-traps-in-FOV ]
    [set fov-list-traps (list)]
  
  ifelse detect_dogs?
    [find-dogs-in-FOV ]
    [set fov-list-dogs (list)]

end

to update_agent_state
  agent_dynamics

  if member? self traps
  [
    set distance_traveled (distance_traveled + .0010 * (item 0 inputs * tick-delta))
    set energy (energy +  (((.0010 * item 0 inputs) ^ 2 + (item 1 inputs * pi / 180) ^ 2) * tick-delta) )
  ]


;   do_collisions


  let nxcor xcor + ( item 0 velocity * tick-delta  ) + (impact-x * tick-delta  ) + (rand-x * tick-delta  )
  let nycor ycor + ( item 1 velocity * tick-delta  ) + (impact-y * tick-delta  ) + (rand-y * tick-delta  )
  

  set true_velocity (list (( item 0 velocity) + (impact-x) + (rand-x )) (( item 1 velocity ) + (impact-y) + (rand-y )))
  set V sqrt ((item 0 true_velocity * item 0 true_velocity) + (item 1 true_velocity * item 1 true_velocity))
  
  ;; makes sure agents don't go through edge (if the calculated next position is more than the boundary, it just forces the agent to stay in place)
  if nxcor > max-pxcor or nxcor < min-pxcor
   [
     set nxcor xcor
     set nycor ycor
     set stuck_count stuck_count + 1
   ]

  if nycor > max-pycor or nycor < min-pycor
    [ set nycor ycor
      set nxcor xcor
      set stuck_count stuck_count + 1]

  setxy nxcor nycor

  let nheading heading + (angular-velocity * tick-delta  ) + (impact-angle * tick-delta ) + (rand-head-distrbuance * tick-delta)
  set heading nheading
end



to add_trap
  ask place-holder ((count stags + count traps))
  [  set breed traps
      st
      setxy 0.3 0
      set sr_patches patches with [(distancexy 0 0 < (number-of-traps * ([size] of trap (count stags  )) / pi)) and pxcor != 0 and pycor != 0]


      move-to one-of sr_patches with [(not any? other turtles in-radius ([size] of trap ( count stags  )))]
      setxy (xcor + .001) (ycor + .001)

      set velocity [ 0 0 ]
      set angular-velocity 0
      set inputs [0 0 0]



      set shape "circle 2"
      set color red
      set size 10 / meters-per-patch ; sets size to 10m

      set mass size

     set levy_time 200
     set color red
    ]

    set number-of-traps (number-of-traps + 1)
end

to remove_trap
ask trap (count stags   + count traps - 1)
  [
    set breed place-holders
    ht
  ]
  set number-of-traps (number-of-traps - 1)

end


to make_trap
  create-traps 1
    [
      set velocity [ 0 0]
      set angular-velocity 0
      set inputs [0 0 0]
      set size 1 / meters-per-patch ;10 meter diameter

      set fov-list-traps (list )
      set fov-list-stags (list )
;      set fov-list-traps-same (list )


      place_traps


      set shape "circle 2"
      set color red
      set mass size

      set levy_time round (100 * (1 / (random-gamma 0.5 (c / 2  ))))
      while [levy_time > (max_levy_time / tick-delta)]
      [set levy_time round (100 * (1 / (random-gamma 0.5 (.5))))]
      choose_rand_turn
      set idiosyncratic_val round (random-normal 0 10)

      set color red

     set coll_angle2 0
     set detect_stags? false
     set detect_traps? false
     set detect_dogs? false

    set detection_response_type "turn-away-in-place"

    set random_switch-timer round random-normal 200 50
    ]
end

to make_dog
  create-dogs 1
    [
      set velocity [ 0 0]
      set angular-velocity 0
      set inputs [0 0 0]
      set size 2 / meters-per-patch;20 meter diameter

      set fov-list-traps (list )
      set fov-list-stags (list )
      set measured_stag_x-position_list (list )
      set measured_stag_y-position_list (list )
      set measured_stag_time_list (list )
      set predicted_stag_ang-velocity_list (list )
      set predicted_stag_speed_list (list )
;      set fov-list-traps-same (list )


      let txcor one-of (range (min-pxcor) (max-pxcor) 0.01)
      let tycor one-of (range (min-pycor) (0) 0.01)
      setxy txcor tycor


      set shape "dog"
      set color blue
      set mass size

      set levy_time round (100 * (1 / (random-gamma 0.5 (c / 2  ))))
      while [levy_time > (max_levy_time / tick-delta)]
      [set levy_time round (100 * (1 / (random-gamma 0.5 (.5))))]
      choose_rand_turn
      set idiosyncratic_val round (random-normal 0 10)

      set color red

     set coll_angle2 0
     set detect_stags? false
     set detect_traps? false
     set detect_dogs? false

    set detection_response_type "turn-away-in-place"

    set random_switch-timer round random-normal 200 50
    ]
end

to make_stag
  create-stags 1
    [
      set velocity [0 0]
      set angular-velocity 0
      set inputs [0 0 0]
      set size 90 / meters-per-patch; 90m diameter

      set fov-list-traps (list )
      set fov-list-stags (list )
      set fov-list-dogs (list)

      set furthest_ycor min-pycor
 
    let rand_x random-normal 0 6.5
    
    if rand_x > max-pxcor
    [set rand_x (max-pxcor - 0.15)]
    
    if rand_x < min-pxcor
    [set rand_x (min-pxcor + 0.15)]

    setxy (rand_x) (max-pycor - (90 / meters-per-patch) / 2)

     set heading 180

      set shape "boat"
      set color red
      set mass size


     set levy_time round (100 * (1 / (random-gamma 0.5 (c / 2  ))))
     while [levy_time > (max_levy_time / tick-delta)]
     [set levy_time round (100 * (1 / (random-gamma 0.5 (.5  ))))]
     choose_rand_turn
     set idiosyncratic_val round (random-normal 0 10)

     set color red
     set coll_angle2 0

      set detect_stags? false
      set detect_traps? false
      set detect_dogs? false

      set detection_response_type "turn-away-in-place"
    ]
end

to place_traps; defines region and/or orientation of where the traps should start
  if trap_setup = "Random - Uniform"
   [
      let tycor one-of (range (min-pycor) (0) 0.01)
      let txcor one-of (range (min-pxcor) (max-pxcor) 0.01)
      setxy txcor tycor
   ]
  
  if trap_setup = "Random - Gaussian"
   [
      let txcor random-normal 0 6.5
      let tycor random-normal -10 3.25
    
      while [txcor > max-pxcor or txcor < min-pxcor]
      [set txcor random-normal 0 6.5]
      
      while [tycor > 0 or tycor < min-pycor]
      [set tycor random-normal -10 3.25]
      
      setxy txcor tycor
   ]
  
  if trap_setup = "Random - Inverse-Gaussian"
   [
    
      let txcor abs random-normal 0 6.5 
      let sign one-of [-1 1]         
      set txcor ( sign * (20 - txcor) )
      
      let tycor abs (random-normal -10 3.25 )
      let sign1 one-of [-1 1]         
      set tycor -10 + ( sign1 * (10 - tycor) )
      
      if txcor > max-pxcor
      [set txcor (max-pxcor - .1)]
        
      if txcor < min-pxcor
      [set txcor (min-pxcor + .1) ]
      
      if tycor > 0
      [set tycor 0]
        
      if tycor < min-pxcor
      [set tycor (min-pycor + .1) ]
      
      
      setxy txcor tycor
   ]

  if trap_setup = "Center Band"
   [
     let tycor one-of (range (-10) (0) 0.01)
     let txcor one-of (range (min-pxcor) (max-pxcor) 0.01)

     setxy txcor tycor
   ]

  if trap_setup = "Barrier"
   [
     let tycor one-of (range (-6) (0) 0.01)
     let txcor one-of (range (min-pxcor) (max-pxcor) 0.01)

     setxy txcor tycor

     ifelse  heading mod 2 = 0
       [
         set heading 90       ]
       [
         set heading 270
       ]
   ]
  
  if trap_setup = "Random Group"
   [

     setxy (rand-xcor + random-normal 0 0.5) (rand-ycor + random-normal 0 0.5)
   ]
end


to trap_setup_strict; if you want to more precisely place the traps (i.e. trap 2 needs to be at position x, etc.)
  if trap_setup = "Imperfect Picket"
   [
     let j number-of-stags
     let jc number-of-stags

     while [j < number-of-stags + number-of-traps]
     [ask trap (j )
       [
         setxy ((j - jc) * (((max-pxcor - min-pxcor) / number-of-traps)) - (max-pxcor - min-pxcor) / 2) (0)

        if xcor > min-pxcor and xcor < max-pxcor
        [
          setxy (xcor + random-normal 0 0.5) (ycor + random-normal 0 0.5)
          set heading (0 + random-normal 0 10)
        ]

         setxy xcor (ycor + 0.01)
       ]
       set j j + 1
     ]
   ]

  if trap_setup = "Perfect Picket"
   [
     let j number-of-stags
     let jc number-of-stags

     while [j < number-of-stags + number-of-traps]
     [ask trap (j )
       [
         setxy ((j - jc) * (((max-pxcor - min-pxcor) / number-of-traps)) - (max-pxcor - min-pxcor) / 2) (0)

        set heading 0

         setxy xcor (ycor + 0.01)
       ]

       set j j + 1
     ]
   ]

end

to dog_setup_strict; if you want to more precisely place the dogs (i.e. dog 2 needs to be at position x, etc.)

  let j number-of-stags + number-of-traps
  let jc number-of-stags + number-of-traps

  while [j < number-of-stags + number-of-traps + number-of-dogs]
     [ask dog (j )
       [
         setxy ((j - jc) * (((max-pxcor - min-pxcor) / number-of-dogs)) - (max-pxcor - min-pxcor) / 4) (-1)

        set heading 0

         setxy xcor (ycor + 0.01)
       ]

       set j j + 1
     ]
   

end


to clear-paint
ask patches
    [
        ifelse pycor = min-pycor
        [set pcolor green]
        [set pcolor white]
    ]
end


to agent_dynamics
  ; Reminder, each patch represents 0.1m, these values below are in terms of patches (i.e. 0.25 patches = 0.025m = 2.5cm)

  let body_v_x (item 0 inputs) * sin (item 1 inputs) ; forward speed
  let body_v_y (item 0 inputs) * -1 * cos( item 1 inputs) ; transversal speed
  let theta_dot (item 2 inputs) ; turning rate
  ; above is altered due to netlogo's definition of 0 deg (or 0 rad). heading of 0 is pointing straight north rather than east.
  ; and heading of 90 deg is east rather than north (i.e. increasing angle means going clockwise rather than counter-clockwise)

  let resultant_v sqrt(body_v_x ^ 2 + body_v_y ^ 2)

  ifelse body_v_x = 0 and body_v_y = 0 ; checks to make sure atan can be used (if the first argument is zero it sometimes creates an error)
  [set body_direct heading]
  [set body_direct atan body_v_y body_v_x]

                                                          ; In traditional coordinates
  let v_x resultant_v * sin(- body_direct + heading)   ; set v_x resultant_v * cos(- body_direct + heading)
  let v_y resultant_v * cos(- body_direct + heading )  ; set v_y resultant_v * sin(- body_direct + heading )
   ; above is altered due to netlogo's definition of 0 deg (or 0 rad). heading of 0 is pointing straight north rather than east.
  ; and heading of 90 deg is east rather than north (i.e. increasing angle means going clockwise rather than counter-clockwise)


  set velocity (list (v_x) (v_y) 0)
  set angular-velocity (theta_dot)
end



to do_collisions
if count other turtles with [breed != discs and breed != centroids and breed != cues] > 0
      [
        let closest-turtle1 (max-one-of place-holders [distance myself])

        if  count traps > 1
        [
          ifelse count traps > 3
          [
            set closest-turtles (min-n-of 2 other turtles with [breed != discs and breed != centroids and breed != cues] [distance myself])

            set closest-turtle1 (min-one-of closest-turtles [distance myself])
            set closest-turtle2 (max-one-of closest-turtles [distance myself])
          ]
          [
            set closest-turtle1 (min-one-of other turtles with [breed != discs and breed != centroids and breed != cues] [distance myself])
          ]
        ]

 
        set closest-turtle closest-turtle1

        ifelse (distance closest-turtle ) < (size + ([size] of closest-turtle)) / 2
           [
              let xdiff item 0 target-diff
              let ydiff item 1 target-diff

              if closest-turtle2 != 0
              [
                let xdiff2 item 0 target-diff2
                let ydiff2 item 1 target-diff2
                set coll_angle2 (rel-bearing2 - (body_direct2))
                ifelse coll_angle2 < -180
                  [
                    set coll_angle2 coll_angle2 + 360
                   ]
                  [
                    ifelse coll_angle2 > 180
                    [set coll_angle2 coll_angle2 - 360]
                    [set coll_angle2 coll_angle2]
                  ]
              ]
              set body_direct2 (360 - body_direct)
              let coll_angle (body_direct2 - rel-bearing); - (90 - heading)); - (body_direct2))
;              let coll_angle (heading + body_direct2) - (rel-bearing)


              if body_direct2 > 180
              [
                set body_direct2 (body_direct2 - 360)
              ]

              ifelse coll_angle < -180
              [
                set coll_angle coll_angle + 360
               ]
              [
                ifelse coll_angle > 180
                [set coll_angle coll_angle - 360]
                [set coll_angle coll_angle]
              ]


              ifelse abs(coll_angle) < 90
              [
                set impact-x  (-1 * item 0 velocity)
                set impact-y  (-1 * item 1 velocity)

                set stuck_count stuck_count + 1
              ]
              [
               set impact-x 0
               set impact-y 0
               set impact-angle 0
              ]

              if closest-turtle2 != 0
              [
                if (distance closest-turtle2 ) < (size + ([size] of closest-turtle)) / 2
                [
                   if abs(coll_angle2) < 90
                   [
                     set impact-x  (-1 * item 0 velocity)
                     set impact-y  (-1 * item 1 velocity)
                   ]
                ]
              ]

                ]
          [
            set wait_ticks 0
            set impact-angle 0
            set impact-x 0
            set impact-y 0
          ]
      ]
end

to find-stags-in-FOV
  let vision-dd 0
  let vision-cc 0
  let real-bearing 0

  (ifelse member? self traps
    [
      set vision-dd vision-distance-traps
      set vision-cc vision-cone-traps
    ]
    member? self stags
    [
      set vision-dd vision-distance-stags
    set vision-cc vision-cone-stags
    ]
    member? self dogs
    [
      set vision-dd vision-distance-dogs
    set vision-cc vision-cone-dogs
    ]
    
    )
  set fov-list-stags (list )
  set i 0

  while [i < (count stags)]
    [
      if self != stag ((i )  )
        [
          let sub-heading towards stag (i ) - heading
          set real-bearing sub-heading

          if sub-heading < 0
            [set real-bearing sub-heading + 360]

          if sub-heading > 180
            [set real-bearing sub-heading - 360]

          if real-bearing > 180
            [set real-bearing real-bearing - 360]

          if (abs(real-bearing) < ((vision-cc / 2))) and (distance-nowrap (stag (i )) < (vision-dd / meters-per-patch));
           [
             set fov-list-stags fput (stag (i)) fov-list-stags
           ]
          ]
     set i (i + 1)
    ]

end


to find-traps-in-FOV
  let vision-dd 0
  let vision-cc 0
  let real-bearing 0

  ifelse member? self traps
    [
      set vision-dd vision-distance-traps
      set vision-cc vision-cone-traps
    ]
    [
      set vision-dd vision-distance-stags
    set vision-cc vision-cone-stags
    ]

  set fov-list-traps (list )
  set i (count stags)



  while [i < (count stags + count traps)]
    [


      if self != trap ((i )  ) 
        [
          let sub-heading towards trap (i ) - heading
          set real-bearing sub-heading

          if sub-heading < 0
            [set real-bearing sub-heading + 360]

          if sub-heading > 180
            [set real-bearing sub-heading - 360]

          if real-bearing > 180
            [set real-bearing real-bearing - 360]


          if (abs(real-bearing) < ((vision-cc / 2))) and (distance-nowrap (trap (i )) < (vision-dd / meters-per-patch));
           [
             set fov-list-traps fput (trap (i)) fov-list-traps
           ]
        ]

     set i (i + 1)
      ]
end

to find-dogs-in-FOV
  let vision-dd 0
  let vision-cc 0
  let real-bearing 0

  ifelse member? self traps
    [
      set vision-dd vision-distance-traps
      set vision-cc vision-cone-traps
    ]
    [
      set vision-dd vision-distance-stags
    set vision-cc vision-cone-stags
    ]

  set fov-list-dogs (list )
  set i (count stags + count traps)



  while [i < (count stags + count traps + count dogs)]
    [


      if self != dog ((i )  ) 
        [
          let sub-heading towards dog (i ) - heading
          set real-bearing sub-heading

          if sub-heading < 0
            [set real-bearing sub-heading + 360]

          if sub-heading > 180
            [set real-bearing sub-heading - 360]

          if real-bearing > 180
            [set real-bearing real-bearing - 360]


          if (abs(real-bearing) < ((vision-cc / 2))) and (distance-nowrap (dog (i )) < (vision-dd / meters-per-patch));
           [
             set fov-list-traps fput (dog (i)) fov-list-traps
           ]
        ]

     set i (i + 1)
      ]
end

to paint-patches-in-FOV

  let vision-dd 0
  let vision-cc 0
  ifelse member? self traps
    [
      set vision-dd vision-distance-traps
      set vision-cc vision-cone-traps
    ]
    [
      set vision-dd vision-distance-stags
    set vision-cc vision-cone-stags
    ]



  set fov-list-patches (list )
  set i 0

  set fov-list-patches patches in-cone (vision-dd / meters-per-patch) (vision-cc) with [(distancexy-nowrap ([xcor] of myself) ([ycor] of myself) <= (vision-dd / meters-per-patch))  and pcolor != black]


  ask fov-list-patches
  [
      ifelse towards myself  > 180
      [
        let sub-heading (towards myself - 180) - [heading] of myself
        set real-bearing-patch sub-heading
        if sub-heading < 0
          [set real-bearing-patch sub-heading + 360]

        if sub-heading > 180
          [set real-bearing-patch sub-heading - 360]

        if real-bearing-patch > 180
          [set real-bearing-patch real-bearing-patch - 360]
      ]
      [
        let sub-heading (towards myself + 180) - [heading] of myself
        set real-bearing-patch sub-heading

        if sub-heading < 0
          [set real-bearing-patch sub-heading + 360]

        if sub-heading > 180
          [set real-bearing-patch sub-heading - 360]

        if real-bearing-patch > 180
          [set real-bearing-patch real-bearing-patch - 360]
      ]

    let current-closest-trap-distance distance myself


     if (real-bearing-patch < ((vision-cc / 2)) and real-bearing-patch > ((-1 * (vision-cc / 2))))
     [
      ifelse member? myself traps
      [
        set pcolor orange
;       set pcolor scale-color red current-closest-trap-distance 0 10 ; Adjust range as needed
      ]
      [set pcolor yellow]
     ]
  ]

end




to-report target-diff  ;; robot reporter
     report
    (   map
        [ [a q] -> a - q]
        (list
          [xcor] of closest-turtle
          [ycor] of closest-turtle)
        (list
          xcor
          ycor))

end

to-report target-diff2  ;; robot reporter
     report
    (   map
        [ [a q] -> a - q]
        (list
          [xcor] of closest-turtle2
          [ycor] of closest-turtle2)
        (list
          xcor
          ycor))
end


to-report rel-bearing
  let xdiff item 0 target-diff
  let ydiff item 1 target-diff
  let angle 0

  let cart-heading (90 - heading)

  ifelse cart-heading < 0
    [set cart-heading cart-heading + 360]
    [set cart-heading cart-heading]

  ifelse cart-heading > 180
    [set cart-heading cart-heading - 360]
    [set cart-heading cart-heading]

  set angle (atan ydiff xdiff)


  let bearing cart-heading - angle
  if bearing < -180
    [set bearing bearing + 360]
  report( bearing )
end

to-report rel-bearing2
  let xdiff2 item 0 target-diff2
  let ydiff2 item 1 target-diff2
  let angle2 0

  let cart-heading2 (90 - heading)

  ifelse cart-heading2 < 0
    [set cart-heading2 cart-heading2 + 360]
    [set cart-heading2 cart-heading2]

  ifelse cart-heading2 > 180
    [set cart-heading2 cart-heading2 - 360]
    [set cart-heading2 cart-heading2]

  if xdiff2 != 0 and ydiff2 != 0
    [set angle2 (atan ydiff2 xdiff2)]


  let bearing2 cart-heading2 - angle2
  if bearing2 < -180
    [set bearing2 bearing2 + 360]
  report( bearing2 )
end