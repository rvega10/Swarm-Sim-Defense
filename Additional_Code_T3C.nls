extensions [palette]
;
; Variable
;
breed [ runners runner]
breed [ hunters hunter]
breed [tails tail]
breed [discs disc]
breed [ sanctuaries sanctuary]
breed[ place-holders place-holder]

globals [ tick-delta
          n
          i
          time-to-first-arrival
          time-to-first-see-list
          time-of-first-runner-detected
          time-of-stuck-runner
          rand-xcor
          rand-ycor
          rand-xcor2
          rand-ycor2
          sr_patches
          number-of-robots
          end_flag
          stuck_flag
          total_velocity_squared
          total_distance_traveled
         ]

runners-own [
           velocity
           angular-velocity   ;; angular velocity of heading/yaw
           inputs             ;; input forces
           closest-turtle     ;; closest target
           impact-x
           impact-y
           impact-angle
           rand-x
           rand-y
           rand-head-distrbuance
           speed-w-noise
           turning-w-noise
           levy_time
           mass
           wait_ticks
           rand_turn
           step_count
           flight_count
           pre_flight_count
           step_time
           flight_time
           pre_flight_time
           closest-turtles
           closest-turtle2
           body_direct
           body_direct2
           coll_angle2
           detection_response_type
           runner_caught_flag
           fov-list-runners
           fov-list-hunters
           fov-list-sanctuaries
           detect_sanctuaries?
           detect_runners?
           detect_hunters?
           stuck_count
           idiosyncratic_val
           furthest_ycor
           trapped_count
           action_step_count
           wind-x
           wind-y
          ] 
          
hunters-own [
          velocity
           angular-velocity   ;; angular velocity of heading/yaw
           inputs             ;; input forces
           closest-turtle     ;; closest target
           impact-x
           impact-y
           impact-angle
           rand-x
           rand-y
           speed-w-noise
           turning-w-noise
           levy_time
           mass
           wait_ticks
           rand_turn
           step_count
           flight_count
           pre_flight_count
           step_time
           flight_time
           pre_flight_time
           closest-turtles
           closest-turtle2
           body_direct
           body_direct2
           coll_angle2
           runner_caught_flag
           detection_response_type
           fov-list-runners
           fov-list-hunters
           fov-list-sanctuaries
           detect_sanctuaries?
           detect_runners?
           detect_hunters?
           stuck_count
           idiosyncratic_val
           action_step_count
           sleep_timer
           rand-head-distrbuance
           distance_traveled
           energy
           ricky_energy
           wait_timer
           wind-x
           wind-y
          ]

tails-own [
          age
          ]
discs-own [
          age
          ]



;;
;; Setup Procedures
;;
to setup
  clear-all
  random-seed seed-no


  set tick-delta 0.1 ; 10 ticks in one second

  let gr (range  (min-pxcor + 1) (max-pxcor - 1) 1)

  set rand-xcor one-of gr
  set rand-ycor one-of gr
  set rand-xcor2 one-of gr
  set rand-ycor2 one-of gr

  set time-to-first-see-list (list )

  ask patches
    [
      ifelse pycor = 20 
      [  
        set pcolor magenta
      ]
      [
        ifelse pycor = -20
        [
          set pcolor orange
        ]
        [
          set pcolor 3 + grey + ( pxcor + pycor ) mod 2 
        ]
      ]
    ]


  
   add_sanctuary
   

  ;creates robots of either species 1 or 2
  set number-of-robots (number-of-runners + number-of-hunters)

  set n number-of-robots

  if same_parameters_between_species?
  [
    set vision-distance2 vision-distance
    set vision-cone2 vision-cone
    set speed2 speed1
    set turning-rate2 turning-rate1
  ]
  
  while [n > (number-of-hunters)]
  [
   make_runner
   set n (n - 1)
  ]

  while [n > 0]
  [
   make_hunter
   set n (n - 1)
  ]
  
  hunter_setup_strict
  
  ; adds extra "ghost" turtles that make adding and removing agents during simulation a bit easier
  create-place-holders 20
  [
    setxy max-pxcor max-pycor
    ht
  ]

   set-default-shape tails "line"
   set-default-shape discs "ring"

  reset-ticks
end

to background_procedures
  clear-paint



 ifelse paint_fov?
        [
          ask discs
            [
               set age age + 1
               if age = 1 [ die ]
             ]
          
          ask runners
          [
;              ask patches with [distance myself < (vision-distance2 * 0.1)]
;              [
;               set pcolor white 
;              ]
            hatch-discs 1 
            [
              set size 2 * (vision-distance2 * 0.1)
              set heading ([heading] of myself)
              palette:set-transparency 50 
            ]
          ]
          if not fog?
            [
              ask hunters
              [
                hatch-discs 1 
                [
                  set size 2 * (vision-distance * 0.1)
                  set heading ([heading] of myself)
                  palette:set-transparency 50 
                ]
              ]
            ]
        ]
       [
         ask discs [die]
       ]

   ifelse draw_path?
         [
         ask runners 
           [pd]
         ask hunters
           [pd]
;            ask tails
;              [
;                 set size 0.5
;                 set age age + 1
;                 if age = 80 [ die ]
;               ]
;  
;            ask runners
;            [hatch-tails 1]
;            ask hunters
;            [hatch-tails 1]
         ]
         [
          ask runners
           [pu]
          ask hunters
           [pu]
           
         ]
end

to measure_results

      if count sanctuaries > 0
      [
        if time-to-first-arrival = 0
        [
          if count runners with [distance min-one-of sanctuaries [distance myself] <= (sanctuary-region-size / 2)] > 0
          [set time-to-first-arrival ticks]
        ]
       ]
        if time-of-first-runner-detected = 0
        [
          if count hunters with [runner_caught_flag = 1] > 0
          [set time-of-first-runner-detected ticks]
        ]

      if time-of-stuck-runner = 0
        [
          if max [trapped_count] of runners > 10000
           [
             set time-of-stuck-runner ticks
           ]
        ]
        
  
  set total_distance_traveled sum [distance_traveled] of hunters
  set total_velocity_squared sum [energy] of hunters
  
      if (time-to-first-arrival > 0) or  (time-of-first-runner-detected > 0) or (time-of-stuck-runner  > 0)
      [set end_flag 1]
end


to select_alg_procedure1
  if selected_algorithm1 = "Alg A"
  [mill]

  if selected_algorithm1 = "Alg B"
  [dispersal]

  if selected_algorithm1 = "VNQ"
  [vnq]

  if selected_algorithm1 = "Standard Random"
  [standard_random_walk]

  if selected_algorithm1 = "Levy"
  [real_levy]
  
  if selected_algorithm1 = "Lie and Wait"
  [lie-and-wait]
  
  if selected_algorithm1 = "Move and Wait"
 [move-and-wait]

 if selected_algorithm1 = "Move and Wait - Idiosyncratic"
 [move-and-wait-idio]

  
  if selected_algorithm1 = "Straight"
  [straight]

end



to select_alg_procedure_runner
  
  if selected_algorithm_runner = "Lie and Wait"
  [lie-and-wait]
  
end

to straight 
  set inputs (list speed-w-noise 0)  
end

to lie-and-wait
      set inputs (list 0 0)   
end

to move-and-wait
  ifelse wait_timer > 500
   [
     set inputs (list 0 0)
     set wait_timer wait_timer - 1
   ]
   [
     set inputs (list speed-w-noise 0)
     set wait_timer wait_timer - 1
     if wait_timer = 0 
      [set wait_timer 2500]
   ] 
end

to move-and-wait-idio
  ifelse wait_timer > 500
   [
     set inputs (list 0 0)
     set wait_timer wait_timer - 1
   ]
   [
     set inputs (list speed-w-noise 0)
     set wait_timer wait_timer - 1
     if wait_timer = 0 
      [set wait_timer round random-normal 2500 100]
   ] 
end


to go_to_sanctuary
   let target_bearing (towards sanctuary 0) - heading
      
      ifelse target_bearing < -180
        [
          set target_bearing target_bearing + 360
         ]
        [
          ifelse target_bearing > 180
          [set target_bearing target_bearing - 360]
          [set target_bearing target_bearing]
        ]
      
      ifelse (target_bearing) > 0 
        [set inputs (list (speed-w-noise) turning-w-noise)]
        [set inputs (list (speed-w-noise) (- turning-w-noise))]
end

  

to mill  ;; robot procedure for milling
  set_actuating_and_extra_variables
  do_sensing
   
   set inputs (list (1 * speed-w-noise) ( 1  * turning-w-noise))
end

to dispersal ; dispersal algorithm (if something is detected, turns right twice as fast)
  set_actuating_and_extra_variables
  do_sensing

  set inputs (list (0 * speed-w-noise) ( 1  * turning-w-noise))  
  
end


to standard_random_walk ;

  ifelse step_count < (step_length_fixed + idiosyncratic_val) ; while step count is less than the set step_length, it should either be turning in place or going straight
  [

    ifelse step_count < (1 / tick-delta) ; for the first 10 ticks of the "step", turn in place at a rate of rand_turn
     [
       set inputs (list (0) rand_turn)
     ]
     [
      set inputs (list speed-w-noise 0) ; if nothing is detected, goes straight forward at a speed of speed-w-noise
       
     ]

    set step_count step_count + 1 ;counts up
  ]
  [
     choose_rand_turn ; at the end of the step, choose random turning rate
     set step_count 0 ; reset turning rate to zero
  ]

end


to real_levy  ;; classic levy that chooses direction at beginning of step and moves straight in that line. Step lengths are chosen from levy distribution

  ifelse step_count < step_time; while step count is less than the the randomly chosen step_length, it should either be turning in place or going straight
  [

    ifelse step_count < (1 / tick-delta) ; for the first 10 ticks of the "step", turn in place at a rate of rand_turn
     [
       set color blue
        set inputs (list (0) rand_turn)
     ]
     [
       set color red
       set inputs (list speed-w-noise 0) ; if nothing is detected, goes straight forward at a speed of speed-w-noise
     ]

    set step_count step_count + 1 ;increment step count
  ]
  [
      ; at the end of the step, choose a new step length from levy distribution and choose random turning rate
       set step_time round (100 * (1 / (random-gamma 0.5 (c / 2  ))))
       while [step_time > round (max_levy_time / tick-delta)]
         [set step_time round (100 * (1 / (random-gamma 0.5 (c / 2 ))))]

       choose_rand_turn
       set step_count 0
  ]
end

to vnq  ;; robot procedure for Q's algorithm. Forces agents to take long flights as well as forces them to search locally for a certain amount
        ;; of time (can't take two flights back to back)


   ifelse pre_flight_count < pre_flight_time  ; the "pre-flight" mode just means the duration of when it is doing the smaller steps before it takes the one large step (aka "flight").
                                              ; pre_flight_time is chosen randomly at the end of each "flight"
     [
      
      ifelse step_count < step_time;  while step count is less than the the randomly chosen step_length, it should either be turning in place or going straight
        [

          ifelse step_count < (1 / tick-delta); for the first 10 ticks of the "step", turn in place at a rate of rand_turn
           [
             set color orange
             set inputs (list (0) rand_turn)
           ]
           [
             set color red
             set inputs (list speed-w-noise 0) ; if nothing is detected, goes straight forward at a speed of speed-w-noise

           ]
        set step_count step_count + 1 ; increment count for steps
      ]
      [
        ; at the end of the step, choose a new step length from normal distribution and choose random turning rate
        set step_time round (random-normal step_time_average step_time_stdev) + 10
        while [step_time <= 0]
          [set step_time round (random-normal step_time_average step_time_stdev) + 10]

        choose_rand_turn
        set step_count 0
      ]
         
     set pre_flight_count pre_flight_count + 1
   ]
   [
     ifelse flight_count < flight_time ; once pre_flight is concluded, it does the "flight" for a duration of "flight_time"
     [
       set inputs (list speed-w-noise 0) ; moves straight forward
       set flight_count flight_count + 1
       set color green
     ]
     [
       ; choose random values for all the time variables and chooses a new random turning rate
       set pre_flight_time round (random-normal pre_flight_time_average pre_flight_time_stdev) + 10

       set flight_time round (random-normal flight_time_average flight_time_stdev) + 10
       while [pre_flight_time <= 0]
       [set pre_flight_time round (random-normal pre_flight_time_average pre_flight_time_stdev) + 10]

       set flight_count 0

       choose_rand_turn
       set pre_flight_count 0
     ]
   ]

end



;
;
;-------------- Nested functions and Setup Procedures below--------------
;
;
 
to detection_response_procedure
  let target (max-one-of place-holders [distance myself])
  let hostile (max-one-of place-holders [distance myself])
  
  ifelse member? self hunters
   [
     ifelse can_distinguish?
      [ set target one-of runners ]
      [
        let closest-runner min-one-of runners [distance myself]
        let closest-hunter min-one-of other hunters [distance myself]
        
        ifelse distance closest-runner > distance closest-hunter 
        [
          set target closest-hunter
        ]
        [
          set target closest-runner
        ]
      ]
   ]
   [
     set target min-one-of sanctuaries [distance myself]
     set hostile min-one-of hunters [distance myself]
   ]
  
  if detection_response_type = "turn-away-in-place"
    [
      let hostile_bearing towards hostile - heading
      
      ifelse hostile_bearing < -180
        [
          set hostile_bearing hostile_bearing + 360
         ]
        [
          ifelse hostile_bearing > 180
          [set hostile_bearing hostile_bearing - 360]
          [set hostile_bearing hostile_bearing]
        ]
      
      ifelse (hostile_bearing) > 0 
        [set inputs (list (speed-w-noise) (- turning-w-noise))]
        [set inputs (list (speed-w-noise) ( turning-w-noise))]
     ]

    if detection_response_type = "reverse-and-turn"
    [
      set inputs (list (- speed-w-noise) 90)
    ]
    
    if detection_response_type = "diffuse-response"
    [
      set inputs (list (- speed-w-noise) 0)
    ]
    
    if detection_response_type = "mill-response"
    [
      set inputs (list (speed-w-noise) (- turning-w-noise))
    ]
    
    if detection_response_type = "90-in-place"
    [
      set inputs (list (0) 90)
    ]
    
    if detection_response_type = "180-in-place"
    [
      set inputs (list (0) 180)
    ]

    if detection_response_type = "forward"
    [
      let target_bearing towards target - heading
      
      ifelse target_bearing < -180
        [
          set target_bearing target_bearing + 360
         ]
        [
          ifelse target_bearing > 180
          [set target_bearing target_bearing - 360]
          [set target_bearing target_bearing]
        ]
      
      ifelse (target_bearing) > 0 
        [set inputs (list (speed-w-noise) turning-w-noise)]
        [set inputs (list (speed-w-noise) (- turning-w-noise))]
     ]
end

to choose_rand_turn
  let turning-rate-val 0 
  ifelse member? self hunters 
    [
      set turning-rate-val turning-rate1
    ]
    [
      set turning-rate-val turning-rate2
    ]
  
  if distribution_for_direction = "uniform"
  [set rand_turn (- turning-rate-val) + (random (2 * turning-rate-val + 1)) ]

  if distribution_for_direction = "gaussian"
  [ set rand_turn round (random-normal 0 (turning-rate-val / 6))]

  if distribution_for_direction = "triangle"
  [set rand_turn (random turning-rate-val) - (random turning-rate-val) ]
end


to set_actuating_and_extra_variables
  
  if ticks mod 1 = 0
  [
    set rand-x random-normal 0 state-disturbance_xy
    set rand-y random-normal 0 state-disturbance_xy
    set rand-head-distrbuance random-normal 0 state-disturbance_head
  ]
  
  set wind-x west-east-wind * 0.1
  set wind-y north-south-wind * 0.1

  ifelse member? self hunters 
  [
    set speed-w-noise random-normal (speed1 * 0.10) (noise-actuating-speed * 0.1)
    set turning-w-noise random-normal (turning-rate1) noise-actuating-turning
  ]
  [
    set speed-w-noise random-normal (speed2 * 0.10) (noise-actuating-speed  * 0.1)
    set turning-w-noise random-normal (turning-rate2) noise-actuating-turning
  ]
end

to do_sensing
  ifelse detect_sanctuaries?
    [find-sanctuaries-in-FOV]
    [set fov-list-sanctuaries (list)]
  
  ifelse detect_runners?
    [find-runners-in-FOV]
    [set fov-list-runners (list)]
    
  ifelse detect_hunters?
    [find-hunters-in-FOV]
    [set fov-list-hunters (list)]

end

to update_agent_state
  agent_dynamics
  
  if member? self hunters
  [
    set distance_traveled (distance_traveled + 10 * (item 0 inputs * tick-delta))
    set energy (energy +  (((10 * item 0 inputs) ^ 2 + (item 1 inputs * pi / 180) ^ 2) * tick-delta) )
  ]

    if collisions?
    [
      do_collisions
    ]

  let nxcor xcor + ( item 0 velocity * tick-delta  ) + (impact-x * tick-delta  ) + (rand-x * tick-delta  + (wind-x * tick-delta))
  let nycor ycor + ( item 1 velocity * tick-delta  ) + (impact-y * tick-delta  ) + (rand-y * tick-delta  + (wind-y * tick-delta))
  
  
  ifelse member? self hunters
  [
    if nxcor > max-pxcor or nxcor < min-pxcor
    [ set nxcor xcor
      set stuck_count stuck_count + 1]
    
    if nycor > max-pycor or nycor < min-pycor;-20
    [ set nycor ycor
      set stuck_count stuck_count + 1]
  ]
  [
    if nxcor > max-pxcor or nxcor < min-pxcor
    [ set nxcor xcor
      set stuck_count stuck_count + 1]
    
    if nycor > max-pycor or nycor < min-pycor
    [ set nycor ycor
      set stuck_count stuck_count + 1]
  ]

  setxy nxcor nycor
  
  let nheading heading + (angular-velocity * tick-delta  ) + (impact-angle * tick-delta ) + (rand-head-distrbuance * tick-delta)
  set heading nheading

end

to update_agent_state_omni
  agent_dynamics_omni
  
    if collisions?
    [
      do_collisions
    ]

  let nxcor xcor + ( item 0 velocity * tick-delta  ) + (impact-x * tick-delta  ) + (rand-x * tick-delta  )
  let nycor ycor + ( item 1 velocity * tick-delta  ) + (impact-y * tick-delta  ) + (rand-y * tick-delta  )
  
  if nxcor > max-pxcor or nxcor < min-pxcor
  [ set nxcor xcor
    set nycor ycor
    set stuck_count stuck_count + 1]
  
  if nycor > max-pycor or nycor < min-pycor
  [ set nycor ycor
    set nxcor xcor
    set stuck_count stuck_count + 1]

  setxy nxcor nycor
  
  let nheading heading + (angular-velocity * tick-delta  ) + (impact-angle * tick-delta ) + (rand-head-distrbuance * tick-delta)
  set heading nheading

end



to add_hunter
  ask place-holder ((count sanctuaries + count runners + count hunters))
  [  set breed hunters
      st
      setxy 0.3 0
      set sr_patches patches with [(distancexy 0 0 < (number-of-robots * ([size] of runner (count sanctuaries)) / pi)) and pxcor != 0 and pycor != 0]
      
      
      move-to one-of sr_patches with [(not any? other turtles in-radius ([size] of runner (count sanctuaries)))]
      setxy (xcor + .01) (ycor + .01)

      set velocity [ 0 0 ]
      set angular-velocity 0
      set inputs [0 0]



      set shape "circle 2"
      set color red
      set size 0.2 ; sets size to 2m diameter

      set mass size

     set levy_time 200
     set color red
    ]

    set number-of-hunters (number-of-hunters + 1)
end

to remove_hunter
ask hunter (count sanctuaries + count runners + count hunters - 1)
  [
    set breed place-holders
    ht
  ]
  set number-of-hunters (number-of-hunters - 1)

end






to add_sanctuary
  create-sanctuaries number-of-sanctuaries
  [
    set shape "sanctuary"


    ifelse random_sanctuary_position?
      [
        let gr (range  (min-pxcor + sanctuary-region-size) (max-pxcor - sanctuary-region-size) 1)
        
        
        setxy (one-of gr) (max-pycor)
      ]
      [
        ;setxy (max-pxcor - ( sanctuary-region-size + 10)) (max-pycor - (sanctuary-region-size + 10))
        start_sanctuaries_in_line
      ]
      
;    setxy (max-pxcor - (sanctuary-region-size * 0.5)) (max-pycor - (sanctuary-region-size * 0.5))

;    ask patches in-radius sanctuary-region-size
;    [set pcolor green]

    set size sanctuary-region-size
    set color green
    if fog?
    [
     ht 
    ]
;    [
;    stamp
;    set size 1
;    set color green
;    ]
  ]
end

to start_sanctuaries_in_circle
let irr max-pxcor * 0.8;
let j 0
let heading_num 360 / number-of-sanctuaries


while [j < number-of-sanctuaries]
[ask sanctuary (j )
  [
    setxy (irr * -1 * cos((j * heading_num) + 90)) (irr * sin((j * heading_num)+ 90))
  ]
  set j j + 1
]
end

to start_sanctuaries_in_line
let irr max-pxcor * 0.8;
let j 0
let heading_num 360 / number-of-sanctuaries


while [j < number-of-sanctuaries]
[ask sanctuary (j )
  [
    setxy ((j * 30) - 30) (45)
  ]
  set j j + 1
]
end


to make_hunter
  create-hunters 1
    [
      set velocity [ 0 0]
      set angular-velocity 0
      set inputs [0 0]
      set size 0.2 ;2 meter diameter 
      let capture_size 1
      ifelse selected_algorithm1 != "Move and Wait - Idiosyncratic"
       [
        set wait_timer 2500
       ]
       [
        set wait_timer round random-normal 2500 100
       ]

      ;set size ((2 * vision-distance * 10 * sin ((vision-cone / 2))))
      ;let capture_size ((2 * vision-distance * 10 * sin ((vision-cone / 2))))
    


      let sr (range ((150  )) ((- 150 )) -.5)
      let pr (range ((max-pxcor * .35 )) ((- (max-pxcor * .35)  )) -.5)
      setxy (one-of pr) (one-of pr)
    
      set fov-list-sanctuaries (list )
      set fov-list-hunters (list )
      set fov-list-runners (list )
      


    
    place_hunters
    
    
      set shape "circle 2"
      set color red
      set mass size
    
      


     set levy_time round (100 * (1 / (random-gamma 0.5 (c / 2  ))))
     while [levy_time > (max_levy_time / tick-delta)]
     [set levy_time round (100 * (1 / (random-gamma 0.5 (.5))))]
     ;set pre_flight_time round (random-normal 400 10) + 10
     set pre_flight_time 2
     ;set pre_flight_time round (random-normal 200 10) + 10
     choose_rand_turn
     set idiosyncratic_val round (random-normal 0 10)

     set flight_time round (random-normal flight_time_average flight_time_stdev) + 10

     set color red

    set coll_angle2 0
    set detect_sanctuaries? false  
    set detect_runners? false
    set detect_hunters? false
    
    set detection_response_type "turn-away-in-place"
    ]
  
end

to make_runner
  create-runners 1
    [
      set velocity [ 0 0]
      set angular-velocity 0
      ifelse selected_algorithm_runner = "Manual Control"
      [
        set inputs [0 0 0 ]
      ]
      [
        set inputs [0 0]
      ]
      set size 0.2; 2m diameter

      let sr (range ((150  )) ((- 150 )) -.5)
      let pr (range ((max-pxcor * .35 )) ((- (max-pxcor * .35)  )) -.5)
      setxy (one-of pr) (one-of pr)
    
    
      set fov-list-sanctuaries (list )
      set fov-list-hunters (list )
      set fov-list-runners (list )
      
      set furthest_ycor min-pycor


      ifelse random_start_region_runner?
        [
         ifelse start_runners_together?
           [
              set sr_patches patches with [pycor < -20 and pxcor != 0]
           ]
           [
             set sr_patches patches with [pycor < -20 and pxcor != 0]
           ]
        ]
        [
          set sr_patches patches with [(distancexy (max-pxcor * 0.55) (max-pycor * 0.55) < (6 * ([size] of runner (count sanctuaries)) / (1) ) + 1) and pxcor != 0 and pycor != 0]
        ]
      


      move-to one-of sr_patches with [(not any? other turtles in-radius ([size] of runner (count sanctuaries)))]
      
      setxy (xcor + .01) (ycor + .01)
      
      set heading towardsxy 0 0 
    
    if selected_algorithm_runner = "Manual Control"
       [
         set heading 0 
       ]


      set shape "runner"
      set color red
      set mass size


     set levy_time round (100 * (1 / (random-gamma 0.5 (c / 2  ))))
     while [levy_time > (max_levy_time / tick-delta)]
     [set levy_time round (100 * (1 / (random-gamma 0.5 (.5  ))))]
     set pre_flight_time round (random-normal 400 10) + 10
     choose_rand_turn
     set idiosyncratic_val round (random-normal 0 10)

     set flight_time round (random-normal 200 10) + 10

     
     set color red
     set coll_angle2 0
     
      set detect_sanctuaries? false  
      set detect_runners? false
      set detect_hunters? false
      
      set detection_response_type "turn-away-in-place"
    ]
end


to place_hunters
  if Hunter_setup = "Random"
  [
      let tycor one-of (range (-20) (20) 0.01)
      let txcor one-of (range (-24) (24) 0.01)    
      
      setxy txcor tycor
  ]
  
  if Hunter_setup = "Center Band"
  [
      let tycor one-of (range (-2) (2) 0.01)
      let txcor one-of (range (-44) (44) 0.01)    
      
      setxy txcor tycor
  ]
  
  if Hunter_setup = "Barrier"
  [
      let tycor one-of (range (-2) (2) 0.01)
      let txcor one-of (range (-24) (24) 0.01)    
      
      setxy txcor tycor
    
      ifelse heading mod 2 = 0
      [
        set heading 90
      ]
      [
       set heading 270 
      ]
  ]
  
  if Hunter_setup = "Dual Barrier"
  [
     let tycor one-of sentence (range (-24) (-20) 0.01) (range (20) (24) 0.01) 
    let txcor one-of (range (-44) (44) 0.01)    
    
    setxy txcor tycor
    
    ifelse heading mod 2 = 0
      [
        set heading 90
      ]
      [
       set heading 270 
      ]  
  ]
  
  if Hunter_setup = "Inverted V"
  [
    let txcor one-of (range (-44) (44) 0.01)
    let selected_xcor txcor
    ifelse selected_xcor > 0
       [setxy selected_xcor (40 - (1.73333 * selected_xcor))]
       [setxy selected_xcor (40 + (1.73333 * selected_xcor))]
       
    
    setxy (xcor + random-normal 0 0.5) (ycor + random-normal 0 0.5)

    ifelse  heading mod 2 = 0
      [
        set heading towardsxy 0 40;random-normal 90 10
      ]
      [
        set heading 180 + towardsxy 0 40;random-normal 270 10
      ]
  ]
  
  if Hunter_setup = "Circle - Center"
  [
   set sr_patches patches with [(distancexy 0 0 < (sqrt(number-of-hunters) * ([size] of runner (count sanctuaries)) * (5) ) + 1) and pxcor != 0 and pycor != 0] 
   move-to one-of sr_patches with [(not any? other turtles in-radius ([size] of runner (count sanctuaries)))]
  ]
  
  if Hunter_setup = "Circle - Random"
  [
   set sr_patches patches with [(distancexy rand-xcor rand-ycor < (sqrt(number-of-hunters) * ([size] of runner (count sanctuaries)) * (5) ) + 1) and pxcor != 0 and pycor != 0] 
   move-to one-of sr_patches with [(not any? other turtles in-radius ([size] of runner (count sanctuaries)))]
  ]
  
  
  if Hunter_setup = "Circle - Center - Facing Out"
  [
   set sr_patches patches with [(distancexy 0 0 < (sqrt(number-of-hunters) * ([size] of runner (count sanctuaries)) * (5) ) + 1) and pxcor != 0 and pycor != 0] 
   move-to one-of sr_patches with [(not any? other turtles in-radius ([size] of runner (count sanctuaries)))]
    
   set heading 180 + towardsxy 0 0 

    
  ]
  
end

to hunter_setup_strict
     if Hunter_setup = "Imperfect Picket"
  [
    let j number-of-sanctuaries + number-of-runners
    let jc number-of-sanctuaries + number-of-runners
    
    while [j < number-of-sanctuaries + number-of-runners + number-of-hunters]
    [ask hunter (j )
      [
        setxy (((j - jc) * (91 / number-of-hunters)) - 44.5) (0)
           
       if xcor > min-pxcor and xcor < max-pxcor
       [
         setxy (xcor + random-normal 0 0.5) (ycor + random-normal 0 0.5)
         set heading (180 + random-normal 0 10)
       ]
      ]
      set j j + 1
    ]
  ]
  
  if Hunter_setup = "Perfect Picket"
  [
    let j number-of-sanctuaries + number-of-runners
    let jc number-of-sanctuaries + number-of-runners
    
    while [j < number-of-sanctuaries + number-of-runners + number-of-hunters]
    [ask hunter (j )
      [
        setxy (((j - jc) * (91 / number-of-hunters)) - 44.5) (0)
           
       set heading 180
      ]
      set j j + 1
    ]
  ]
end



to clear-paint
ask patches
      [
       ifelse pycor = 20 
         [  
           set pcolor magenta
         ]
         [
           ifelse pycor = -20
           [
             set pcolor orange
           ]
           [
             set pcolor 3 + grey + ( pxcor + pycor ) mod 2 
           ]
         ]
     ]
      
end

to agent_dynamics
  let v_x item 0 inputs * sin(heading)
  let v_y item 0 inputs * cos(heading)
  let theta_dot item 1 inputs

  set velocity (list (v_x) (v_y) 0)
  set angular-velocity theta_dot
  
  let body_v_x (item 0 inputs) * sin (90) ; forward speed
  let body_v_y (item 0 inputs) * -1 * cos( 90) ; transversal speed
  
  ifelse body_v_x = 0 and body_v_y = 0 ; checks to make sure atan can be used (if the first argument is zero it sometimes creates an error)
  [set body_direct heading]
  [set body_direct atan body_v_y body_v_x]
  
  ifelse v_x = 0 and v_y = 0 ; checks to make sure atan can be used (if the first argument is zero it sometimes creates an error)
  [set body_direct heading]
  [set body_direct atan v_y v_x]
end

to agent_dynamics_omni
  ; Reminder, each patch represents 10m, these values below are in terms of patches (i.e. 0.25 patches = 0.025m = 2.5cm)
  
  let body_v_x (item 0 inputs) * sin (item 1 inputs) ; forward speed
  let body_v_y (item 0 inputs) * -1 * cos( item 1 inputs) ; transversal speed
  let theta_dot (item 2 inputs) ; turning rate
  ; above is altered due to netlogo's definition of 0 deg (or 0 rad). heading of 0 is pointing straight north rather than east.
  ; and heading of 90 deg is east rather than north (i.e. increasing angle means going clockwise rather than counter-clockwise
  ; normally it'd be
  ;   set theta_dot ( -item 0 inputs + item 1 inputs - item 2 inputs + item 3 inputs) * (R / (4 * (lx + ly)))


  let resultant_v sqrt(body_v_x ^ 2 + body_v_y ^ 2)

  ifelse body_v_x = 0 and body_v_y = 0 ; checks to make sure atan can be used (if the first argument is zero it sometimes creates an error)
  [set body_direct heading]
  [set body_direct atan body_v_y body_v_x]

                                                          ; In traditional coordinates
  let v_x resultant_v * sin(- body_direct + heading)   ; set v_x resultant_v * cos(- body_direct + heading)
  let v_y resultant_v * cos(- body_direct + heading )  ; set v_y resultant_v * sin(- body_direct + heading )
   ; above is altered due to netlogo's definition of 0 deg (or 0 rad). heading of 0 is pointing straight north rather than east.
  ; and heading of 90 deg is east rather than north (i.e. increasing angle means going clockwise rather than counter-clockwise
  ; normally it'd be
  ;   set theta_dot ( -item 0 inputs + item 1 inputs - item 2 inputs + item 3 inputs) * (R / (4 * (lx + ly)))



  set velocity (list (v_x) (v_y) 0)
  set angular-velocity (theta_dot)
end



to do_collisions
if count other turtles with [breed != tails and breed != discs and breed != sanctuaries] > 0
      [
        let closest-turtle1 (max-one-of place-holders [distance myself])

        if count runners + count hunters > 1
        [
          ifelse count runners + count hunters > 3
          [
            set closest-turtles (min-n-of 2 other turtles with [breed != tails and breed != discs and breed != sanctuaries] [distance myself])

            set closest-turtle1 (min-one-of closest-turtles [distance myself])
            set closest-turtle2 (max-one-of closest-turtles [distance myself])
          ]
          [
            set closest-turtle1 (min-one-of other turtles with [breed != tails and breed != discs and breed != sanctuaries] [distance myself])
          ]
        ]


        set closest-turtle closest-turtle1

        ifelse (distance closest-turtle ) < (size + ([size] of closest-turtle)) / 2
           [
              let xdiff item 0 target-diff
              let ydiff item 1 target-diff

              if closest-turtle2 != 0
              [
                let xdiff2 item 0 target-diff2
                let ydiff2 item 1 target-diff2
                set coll_angle2 (rel-bearing2 - (body_direct2))
                ifelse coll_angle2 < -180
                  [
                    set coll_angle2 coll_angle2 + 360
                   ]
                  [
                    ifelse coll_angle2 > 180
                    [set coll_angle2 coll_angle2 - 360]
                    [set coll_angle2 coll_angle2]
                  ]
              ]
              set body_direct2 (360 - body_direct)
              let coll_angle (rel-bearing); - (90 - heading)); - (body_direct2))


              if body_direct2 > 180
              [
                set body_direct2 (body_direct2 - 360)
              ]

              ifelse coll_angle < -180
              [
                set coll_angle coll_angle + 360
               ]
              [
                ifelse coll_angle > 180
                [set coll_angle coll_angle - 360]
                [set coll_angle coll_angle]
              ]

              ifelse collision_stop?
              [
                    ifelse abs(coll_angle) < 90
                    [
                      set impact-x  (-1 * item 0 velocity)
                      set impact-y  (-1 * item 1 velocity)
                    
                      set stuck_count stuck_count + 1
                    ]
                    [
                     set impact-x 0
                     set impact-y 0
                     set impact-angle 0
                    ]
                    
                    if closest-turtle2 != 0
                    [
                      if (distance closest-turtle2 ) < (size + ([size] of closest-turtle)) / 2
                      [
                         if abs(coll_angle2) < 90
                         [
                           set impact-x  (-1 * item 0 velocity)
                           set impact-y  (-1 * item 1 velocity)
                         ]
                      ]
                    ]
                ]
                [
                  ifelse elastic_collisions?
                    [
                       let my_vx item 0 velocity
                       let my_vy item 1 velocity
                       let my_cx xcor
                       let my_cy ycor
                       let m1 mass

                       let other_vx [item 0 velocity] of closest-turtle
                       let other_vy [item 1 velocity] of closest-turtle
                       let other_cx [xcor] of closest-turtle
                       let other_cy [ycor] of closest-turtle
                       let m2 [mass] of closest-turtle

                       let f1 ((my_vx - other_vx)*(my_cx - other_cx) + (my_vy - other_vy)*(my_cy - other_cy))
                       let hh1 ((my_cx - other_cx) ^ 2 + (my_cy - other_cy) ^ 2)
                       let mass_prod1 (2 * m2)/(m1 + m2)

                       let f2 ((other_vx - my_vx)*(other_cx - my_cx) + (other_vy - my_vy)*(other_cy - my_cy))
                       let hh2 ((other_cx - my_cx) ^ 2 + (other_cy - my_cy) ^ 2)
                       let mass_prod2 (2 * m1)/(m1 + m2)



                       let v_x_1 (my_vx - (mass_prod1 * f1 / hh1)*(my_cx - other_cx))
                       let v_y_1 (my_vy - (mass_prod1 * f1 / hh1)*(my_cy - other_cy))

                       let v_x_2 (other_vx - (mass_prod2 * f2 / hh2)*(other_cx - my_cx))
                       let v_y_2 (other_vy - (mass_prod2 * f2 / hh2)*(other_cy - my_cy))


                       set color green
                       set velocity (list (v_x_1) (v_y_1) 0)

                       if v_x_1 != 0 or v_y_1 != 0
                         [
                           set heading ((atan  v_x_1 v_y_1));]
                         ]

                       set wait_ticks wait_ticks + 4

                       ask closest-turtle
                         [
                           set color green
                           set velocity (list (v_x_2) (v_y_2) 0)
                           if v_x_2 != 0 or v_y_2 != 0
                             [
                               set heading ( (atan  v_x_2 v_y_2))
                             ]

                           set wait_ticks wait_ticks + 2
                         ]

                       set wait_ticks wait_ticks - 1

                       if wait_ticks < 0
                         [set wait_ticks 0]

                       if distance closest-turtle < (size + ([size] of closest-turtle)) / 2
                         [
                           set impact-x -1 * sin (towards closest-turtle)
                           set impact-y -1 * cos (towards closest-turtle)
                         ]
                      ]
                    [
                      ifelse rel-bearing >= 0 and rel-bearing <= 75
                        [
                          set impact-angle (.7 * item 1 inputs)
                          set impact-x  (-1 * item 0 velocity)
                          set impact-y  (-1 * item 1 velocity)
                        ]
                        [
                          ifelse rel-bearing < 0 and rel-bearing >= -75
                            [
                              set impact-angle (-.7 * item 1 inputs)
                              set impact-x  (-1 * item 0 velocity)
                              set impact-y  (-1 * item 1 velocity)
                            ]
                            [
                              set impact-x 0
                              set impact-y 0
                            ]
                         ]
                       ]
                    ]
                ]
          [
            set wait_ticks 0
            set impact-angle 0
            set impact-x 0
            set impact-y 0
          ]
      ]
end

to find-runners-in-FOV
  let vision-dd 0
  let vision-cc 0
  let real-bearing 0
  
  ifelse member? self hunters 
    [
      set vision-dd vision-distance
      set vision-cc vision-cone
    ]
    [
      set vision-dd vision-distance2
    set vision-cc vision-cone2
    ]
  set fov-list-runners (list )
  set i (count sanctuaries)

  while [i < (count sanctuaries + count runners)]
    [
      if self != runner ((i )  )
        [
          let sub-heading towards runner (i ) - heading
          set real-bearing sub-heading

          if sub-heading < 0
            [set real-bearing sub-heading + 360]

          if sub-heading > 180
            [set real-bearing sub-heading - 360]

          if real-bearing > 180
            [set real-bearing real-bearing - 360]

          if (abs(real-bearing) < ((vision-cc / 2))) and (distance-nowrap (runner (i )) < (vision-dd * 0.10));
           [
             set fov-list-runners fput (runner (i)) fov-list-runners
           ]
          ]
     set i (i + 1)
    ]
    
end

to find-hunters-in-FOV
  let vision-dd 0
  let vision-cc 0
  let real-bearing 0
  
  ifelse member? self hunters 
    [
      set vision-dd vision-distance
      set vision-cc vision-cone
    ]
    [
      set vision-dd vision-distance2
    set vision-cc vision-cone2
    ]
  
  set fov-list-hunters (list )
  set i (count sanctuaries + count runners)

  while [i < (count sanctuaries + count runners + count hunters)]
    [
      if self != hunter ((i )  )
        [
          let sub-heading towards hunter (i ) - heading
          set real-bearing sub-heading

          if sub-heading < 0
            [set real-bearing sub-heading + 360]

          if sub-heading > 180
            [set real-bearing sub-heading - 360]

          if real-bearing > 180
            [set real-bearing real-bearing - 360]


          if (abs(real-bearing) < ((vision-cc / 2))) and (distance-nowrap (hunter (i )) < (vision-dd * 0.10));
           [
             set fov-list-hunters fput (hunter (i)) fov-list-hunters
           ]                   
        ]
     set i (i + 1)
    ]
end



to find-sanctuaries-in-FOV
  let vision-dd 0
  let vision-cc 0
  ifelse member? self hunters 
    [
      set vision-dd vision-distance
      set vision-cc vision-cone
    ]
    [
      set vision-dd vision-distance2
    set vision-cc vision-cone2
    ]
  
  set fov-list-sanctuaries (list )
  set i 0

  while [i < count sanctuaries]
  [
    if distance-nowrap (sanctuary (i )) < ((vision-dd * 0.10) + (0.5 * sanctuary-region-size));
    [
      set fov-list-sanctuaries fput (sanctuary (i)) fov-list-sanctuaries
    ]   
    
    set i (i + 1)
   ]
end




to-report target-diff  ;; robot reporter
     report
    (   map
        [ [a q] -> a - q]
        (list
          [xcor] of closest-turtle
          [ycor] of closest-turtle)
        (list
          xcor
          ycor))

end

to-report target-diff2  ;; robot reporter
     report
    (   map
        [ [a q] -> a - q]
        (list
          [xcor] of closest-turtle2
          [ycor] of closest-turtle2)
        (list
          xcor
          ycor))
end


to-report rel-bearing
  let xdiff item 0 target-diff
  let ydiff item 1 target-diff
  let angle 0

  let cart-heading (90 - heading)

  ifelse cart-heading < 0
    [set cart-heading cart-heading + 360]
    [set cart-heading cart-heading]

  ifelse cart-heading > 180
    [set cart-heading cart-heading - 360]
    [set cart-heading cart-heading]

;  if xdiff != 0 and ydiff != 0
;    [set angle (atan ydiff xdiff)]
  
  set angle (atan ydiff xdiff)


  let bearing cart-heading - angle
  if bearing < -180
    [set bearing bearing + 360]
  report( bearing )
end

to-report rel-bearing2
  let xdiff2 item 0 target-diff2
  let ydiff2 item 1 target-diff2
  let angle2 0

  let cart-heading2 (90 - heading)

  ifelse cart-heading2 < 0
    [set cart-heading2 cart-heading2 + 360]
    [set cart-heading2 cart-heading2]

  ifelse cart-heading2 > 180
    [set cart-heading2 cart-heading2 - 360]
    [set cart-heading2 cart-heading2]

  if xdiff2 != 0 and ydiff2 != 0
    [set angle2 (atan ydiff2 xdiff2)]


  let bearing2 cart-heading2 - angle2
  if bearing2 < -180
    [set bearing2 bearing2 + 360]
  report( bearing2 )
end

